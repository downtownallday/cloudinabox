#!/usr/bin/perl

use strict;
use warnings;
use JSON;
use Carp;
use Try::Tiny;
use Digest::SHA qw(sha1_hex);

# logwatch detail:
#  0 (low): display only errors and security-related issues
#  5 (med): display anything that a typical admin would want to see
# 10 (high): display anything that a paranoid admin would want to see

my $debug = $ENV{'LOGWATCH_DEBUG'} || 0;
my $detail_level = $ENV{'LOGWATCH_DETAIL_LEVEL'} || 0;
my $format_type = $ENV{'LOGWATCH_FORMAT_TYPE'};  # always lowercase
my $range = $ENV{'LOGWATCH_DATE_RANGE'};
my $tmpdir = $ENV{'LOGWATCH_TEMP_DIR'};

my $json = JSON->new;
$json->relaxed($JSON::true);
$json->allow_unknown($JSON::true);
$json->max_size(0);
my $lineno = -1;

# Nextcloud logging levels:
# 0: DEBUG: All activity; the most detailed logging.
# 1: INFO: Activity such as user logins and file activities, plus warnings, errors, and fatal errors.
# 2: WARN: Operations succeed, but with warnings of potential problems, plus errors and fatal errors.
# 3: ERROR: An operation fails, but other services and operations continue, plus fatal errors.
# 4: FATAL: The server stops.

my @NC_LEVEL_NAMES= (
    'DEBUG',   # 0
    'INFO',    # 1
    'WARNING', # 2
    'ERROR',   # 3
    'FATAL'    # 4
    );

my @NC_LEVEL_NAMES_FRIENDLY= (
    'Debug',
    'Information',
    'Warnings',
    'Errors',
    'Fatal Errors'
    );
    
sub level_name_from_level() {
    my ($level, $friendly) = @_;
    if ($level > $#NC_LEVEL_NAMES) {
        croak "Invalid level $level";
    }
    if (! defined($friendly) || $friendly) {
        return $NC_LEVEL_NAMES_FRIENDLY[$level];
    }
    else {
        return $NC_LEVEL_NAMES[$level];
    }
}

sub hash_of_detail() {
    my ($detail_ref) = @_;
    my $v = $detail_ref->{"message"};
    return sha1_hex($v);
}

sub combine_detail() {
    # modifies $d2 by combining $d1 into $d2. it's assumed that $d1
    # and $d2 have the same hash as returned by hash_of_detail()
    my ($d1, $d2) = @_;
    $d2->{"_count"} += $d1->{"_count"};
    foreach my $user ( keys %{$d1->{"users"}} ) {
        $d2->{"users"}->{$user} =
            ($d2->{"users"}->{$user} || 0) +
            $d1->{"users"}->{$user};
    }
    foreach my $url ( keys %{$d1->{"urls"}} ) {
        my $d1url = $d1->{"urls"}->{$url};
        my $d2url = $d2->{"urls"}->{$url};
        if (! defined($d2url)) {
            $d2->{"urls"}->{$url} = $d1url;
        }
        else {
            $d2url->{"count"} += $d1url->{"count"};
            if (! defined($d2url->{"exception"})) {
                $d2url->{"exception"} = $d1url->{"exception"};
            }
        }
    }
}


#
# organize log entries by log level, then by app name
#
my $byapp = {
    # 'ERROR' => {
    #   'app' => [
    #       {
    #         urls: { 'PUT /uri/path/': { count:n, exception:{ Exception:"", Message:"" } } },
    #         message:'',
    #         users:{'alice':n},
    #         _count: n
    #       },
    #       ...
    #   ],
    #   ...
    # },
    # ...
};


while(defined(my $line = <STDIN>)) {
    ++$lineno;
    try {
        my $lineref = $json->decode($line);
        my $level = $lineref->{"level"};
        if (
            # Low detail: warning, error and fatal log entries
            $detail_level < 5 && $level < 2 ||
            # Med detail: include info entries
            $detail_level < 10 && $level < 1
            # High: include debug entries
            ) {
            croak "skip";
        }
        
        my $detail = {
            urls => {
                $lineref->{"method"} . " " . $lineref->{"url"} => {
                    count => 1,
                    method => $lineref->{"method" },
                    url => $lineref->{"url"},
                    exception => $lineref->{"exception"}
                }
            },
            message => $lineref->{"message"},
            users => { $lineref->{"user"} => 1 },
            _count => 1,
        };

        if (! $detail->{"message"} && defined($lineref->{"exception"})) {
            $detail->{"message"} = $lineref->{"exception"}->{"Exception"};
        }
        
        my $level_name = &level_name_from_level($level, 0);
        if (! defined $byapp->{$level_name}) {
            $byapp->{$level_name} = {};
        }
        
        my $app = $lineref->{"app"};
        if (! defined $byapp->{$level_name}->{$app}) {
            $byapp->{$level_name}->{$app} = {};
        }

        my $detail_hash = &hash_of_detail($detail);
        if (! defined $byapp->{$level_name}->{$app}->{$detail_hash}) {
            $byapp->{$level_name}->{$app}->{$detail_hash} = $detail;
        }
        else {
            &combine_detail(
                 $detail,
                 $byapp->{$level_name}->{$app}->{$detail_hash}
            );
        }
            
    } catch {
        # couldn't decode or some other failure
        if ($_ !~ /^skip / && $debug>0) {
            chomp($line);
            print STDERR "Could not parse input line $lineno: $line: $_\n";
        }

    };
}

#
# print the report
#
$lineno = -1;
my $indent = " "x3;

for (my $level=4; $level>=0; $level--) {
    my $level_name = &level_name_from_level($level, 0);
    if (! defined $byapp->{$level_name}) {
        next;
    }
    ++$lineno;
    
    my $level_name_friendly = &level_name_from_level($level, 1);
    if ($lineno >0) { print "\n"; }
    if ($format_type eq 'html') {
        print "$level_name_friendly\n";
    }
    else {
        print "*** ", $level_name_friendly, " ***\n";
    }

    my $appidx = -1;
    my $indent_amt = 1;
    
    foreach my $app (sort keys %{$byapp->{$level_name}}) {
        ++$appidx;
        if ($appidx > 0) { print "\n"; }
        print ${indent}x$indent_amt, $app, ":\n";
        my $app = $byapp->{$level_name}->{$app};
        ++$indent_amt;
        
        foreach my $detail_hash (keys %$app) {
            my $detail = $app->{$detail_hash};
            my @users = sort { lc($a) cmp lc($b) } keys %{$detail->{"users"}};
            my $users_msg = " [" . join(",", @users) . "]";
            if ($#users == 0 && $users[0] eq '--') {
                $users_msg = "";
            }

            print ${indent}x$indent_amt, $detail->{"_count"}, " times", $users_msg, ": ", $detail->{"message"}, "\n";
            ++$indent_amt;

            if ($detail_level >= 5) {
                # logwatch Medium detail or higher
                my @urlkeys = sort { $detail->{"urls"}->{$b}->{"count"} <=> $detail->{"urls"}->{$a}->{"count"} } keys %{$detail->{"urls"}};
                if ($#urlkeys == 0 && $detail->{"urls"}->{$urlkeys[0]}->{"method"} eq "") {
                    # special case: internal NC error not caused by a web request
                }
                else {            
                    foreach my $urlkey (@urlkeys) {
                        my $url = $detail->{"urls"}->{$urlkey};
                        print ${indent}x$indent_amt, "->", $url->{"count"}, ":", $urlkey;
                        if (defined($url->{"exception"})) {
                            print " (", $url->{"exception"}->{"Exception"}, ")";
                        }
                        print "\n";
                    }
                }
            }
        }
    }
}
